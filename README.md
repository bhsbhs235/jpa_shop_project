#Spring project

- jpa 

주의

- @Setter는 편의상 해둔거지만 실무에서는 많은 문제를 야기할 수 있으므로 쓰지 않는 것이 좋다
- 실무에서는 @ManyToMany는 쓰지 말자
- @Id @Column(name = "member_id") 테이블에는 id 말고 컬럼을 정해주는 것이 좋다
- 값 타입(Embeddable)은 변경 불가능하게 설계해야 한다.
    JPA 스펙상 엔티티나 임베디드 타입은 자바 기본 생성자를 public 또는 protected로 설정해야 한다. 
  protected가 안전하다 JPA가 이런 제약을 두는 이유는 JPA 구현 라이브러리가 객체를 생성할 때 리플렉션 같은 기술을
    사용할 수 있도록 지원해야 하기 때문이다.
- 모든 연관관계는 지연로딩으로 설정하여야 한다. 
  - 연관된 엔티티를 함께 DB에서 조회해야 하면, fetch join 또는 엔티티 그래프 기능을 사용한다.
  - ManyToOne, OneToOne 은 기본 값이 EAGER라 LAZY로 설정해줘야 한다.
- 테이블, 컬럼명 생성 전략
  - 기본 전략(SpringImpliciNamingStrategy) 
    - 카멜 케이스 -> 언더스코어 _
    - . -> 언더스코어 _
    - 대문자 -> 소문자
  - 커스터 마이징 가능
- 연관관계 매핑은 기준이 되는 엔티티에서 연관관계에 있는 엔티티들을 조회할 일이 있을 때 보통 설정합니다.
Order에서 OrderItem을 조회하는 로직이 요구사항에서 필요하기 때문에 연관관계를 설정해준 것입니다. 만약 Item에서 OrderItem을 조회할 필요가 있다면 설정했지만, 해당 프로젝트 현재 상황에서는 그럴 필요가 없으니 연관관계 설정을 해주지 않은 것
- 준영속 엔티티 : 영속성 컨텍스트가 더는 관리하지 않는 엔티티를 말한다.
- 준영속 엔티티를 수정하는 2가지 방법
  - 변경 감지 기능 사용
    - Item findItem = em.find(Item.class, itemPara.getId());
    - findItem.setPrice(itemParam.getPrice()); 
    - 영속성 컨텍스트에서 엔티티를 다시 조회한 후 수정하면 트랜잭션 커밋 시점에 더티체킹으로 동작 감지
  - 병합 사용 ( 실무에서는 되도록이면 귀찮더라도 변경 감지를 사용하자 )
    - 병합은 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용하는 기능
    - merge(member)를 실행한다.
    - 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회한다.
    - 1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고, 1차 캐시에 저장한다.
    - 조회한 엔티티(예: mergeMember라고 편의상 하겠다)에 member 엔티티의 값을 채워 넣는다
    - mergeMember의 이름이 바뀐다 "회원1" -> "회원2" 변경감지를 한다.
    - 영속 상태인 "mergeMember"를 반환한다. (member)가 아니다.
    - 따라서 뒤에서 계속 엔티 변경감지를 쓰려면 반환값인 mergeMember를 써야한다.
    
    **\*주의*** 
    - 변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경된다.
    - 변경시 값이 없으면 null로 업데이트 될 위험이 매우 크다!!! (병합은 모든 필드를 교체하기 때문에)
  - 컨트롤러에서 엔티티를 생성하지 말자
  - 트랜잭션이 있는 서비스 계층에 식별자와 변경할 데이터를 명확하게 전달(dto 객체로)
  - 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회하고, 엔티티의 데이터를 직접 변경
- 영속성 컨텍스트 트랜잭션 범위
  - Spring에서 Controller단의 경우 트랜잭션 범위 밖이기 때문에 읽기만 가능하며, 읽을때에도 영속성 컨텍스트에 등록은 된다.
       (기본적으로 open-in-view : true이기 때문에)
  - 하지만 말 그대로 "읽기"이기 때문에 persist / merge / flush 등을 호출시 에러를 터트려 트랜잭션 범위 밖에서는 값을 변경할 수 없다.
  - 그럼에도 아래의 코드로 item의 price와 name이 변경되는 것은 1번에 의해 item은 영속성 컨텍스트로 관리되고 있었기 때문이고 orderService의 order()가 종료될 때 플러시 발생 -> 더티체킹 동작시 DB에서 불러왔을때와 다르니 정상적으로 update 발생
  - 만약 application.yml에서 open-in-view : false로 변경 시
   컨트롤러단에서 find 한 엔티티들은 영컨에 등록되지 않아
   더티체킹도 안될 뿐더러 넘겨받은 member / item을 service단에서 그대로 사용하려 할 경우 에러 발생 (org.hibernate.LazyInitializationException: could not initialize proxy)